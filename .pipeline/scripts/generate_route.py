#!/usr/bin/env python3

'''
Generating Route given the start location and amenities data set
'''

import numpy as np
import pandas as pd
from sklearn.neighbors import BallTree

from shared_methods import Helper

VAN_LAT_TO_KM = 72 # Approximation for Vancouver's latitude
VAN_LON_TO_KM = 111 # One longitude is usually ~111km anywhere

# read environment variables
helper = Helper()
location, hungriness, interestingness, duration, point_time = helper.read_config(["location", "hungriness", "interestingness", "duration", "point_time"])
weighted_data = helper.load_data('./.pipeline/artifacts/weighted_amenities-vancouver.csv')

# np.random.seed(42)


# find the closest k points to a given point
def find_closest_points(tree, p_lat, p_lon, k=10, epsilon=0.001):
    p_lat += np.random.uniform(-epsilon, epsilon)
    p_lon += np.random.uniform(-epsilon, epsilon)
    dist, index = tree.query([(p_lat, p_lon)], k=k)
    return index[0], dist[0]

# calculate route given the start point with Ball Tree
def calculate_route(weighted_data, start_point, max_points=10):
    indices = []
    visited = set([])
    total_distance = 0 # total straight line distance between points
    est_total_hours = 0
    # seperate out food places
    data = weighted_data[weighted_data['food'] == 0].reset_index(drop=True)
    balltree = BallTree(data[['lat', 'lon']].values, leaf_size=15, metric='haversine')
    # food
    food = weighted_data[weighted_data['food'] == 1].reset_index(drop=True)
    balltree_food = BallTree(food[['lat', 'lon']].values, leaf_size=15, metric='haversine')

    for i in range(max_points):
        if len(visited) == 0:
            current_point = start_point
        else:
            current_point = weighted_data.iloc[indices[-1]]

        cur_balltree = balltree
        cur_data = data

        # If hungriness is reached, pick a foodplace instead
        if i != 0  and i % hungriness == 0:
            cur_balltree = balltree_food
            cur_data = food

        # Use balltree to locate next k points
        neighbors, distances = find_closest_points(cur_balltree, current_point['lat'], current_point['lon'], k=30)
        adjusted_distances = []

        # Adjust distances with weights, making more interesting places seem closer for the purpose of sorting
        for neighbor, distance in zip(neighbors, distances):
            weight = cur_data.loc[neighbor]['weight']
            weighted_distance = distance/(weight ** (0.5*interestingness))
            adjusted_distances.append((neighbor, weighted_distance))

        # Sort k points by weighted distance
        adjusted_distances.sort(key=lambda x: x[1])

        # From sorted list, check neighbours and if not visited, use as next point
        for neighbor, weighted_distance in adjusted_distances:
            if neighbor not in visited:
                lat = cur_data.iloc[neighbor]['lat']
                lon = cur_data.iloc[neighbor]['lon']
                weighted_data_index = weighted_data.query("lat == @lat & lon == @lon").index[0]
                indices.append(weighted_data_index)
                visited.add(neighbor)
                # Get l1 norm distance between two points
                # more reliable for time and distance estimation
                lat_diff_km = abs(current_point['lat'] - lat) * VAN_LAT_TO_KM
                lon_diff_km = abs(current_point['lon'] - lon) * VAN_LON_TO_KM
                l1_distance = lat_diff_km + lon_diff_km
                total_distance += l1_distance
                # 30km/h is good estimation average driving speed
                est_total_hours += (l1_distance / 30) + point_time 
                break

        if est_total_hours >= duration:
            break

    return weighted_data.iloc[indices], total_distance, est_total_hours


# for each point in the route, stitch the route generated by OSRM query between each point
def stitch_route(route):
    stitch_distance = 0
    stitch_duration = 0
    stitched_route = pd.DataFrame(columns=['lon', 'lat'])
    coordinates = [(lon, lat) for lon, lat in zip(route['lon'], route['lat'])]
    route_raw = helper.osrm_route_query(coordinates)
    route_coords = route_raw['routes'][0]['geometry']['coordinates']
    stitched_route = pd.DataFrame(route_coords, columns=['lon', 'lat'])
    stitch_distance = (route_raw['routes'][0]['distance'] / 1000)
    stitch_duration = (route_raw['routes'][0]['duration'] / 3600) + (point_time * len(route))

    return stitched_route, stitch_distance, stitch_duration


# main function
point = pd.Series({'lat': location[1], 'lon': location[0]})

all_routes = pd.DataFrame(columns=['route', 'distance', 'duration'])

# test three routes
for i in range(3):
    route, est_distance, est_total_hours = calculate_route(weighted_data, point, 100)
    route_df = pd.DataFrame([stitch_route(route)], columns=['route', 'distance', 'duration'])
    if all_routes.empty:
        all_routes = route_df
    all_routes = pd.concat([all_routes, route_df], ignore_index=True)
# pick route with duration closest to requested duration
closest_route = all_routes.iloc[(all_routes['duration'] - duration).abs().idxmin()]


# save route to csv and distance and duration to json
distance_duration = {
    "distance": round(closest_route['distance'], 2),
    "duration": round(closest_route['duration'], 2)
}
helper.add_config(distance_duration)
closest_route['route'].to_csv('./.pipeline/artifacts/route.csv', index=False)
# np.save('./.pipeline/artifacts/route.npy', route)